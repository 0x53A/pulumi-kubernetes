// *** WARNING: this file was generated by the Pulumi Kubernetes codegen tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v1beta1

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/go/pulumi"
)

// CSINodeDriver holds information about the specification of one CSI driver installed on a node
type CSINodeDriver struct {
	// allocatable represents the volume resources of a node that are available for scheduling.
	Allocatable *VolumeNodeResources `pulumi:"allocatable"`

	// This is the name of the CSI driver that this object refers to. This MUST be the same name
	// returned by the CSI GetPluginName() call for that driver.
	Name string `pulumi:"name"`

	// nodeID of the node from the driver point of view. This field enables Kubernetes to communicate
	// with storage systems that do not share the same nomenclature for nodes. For example, Kubernetes
	// may refer to a given node as "node1", but the storage system may refer to the same node as
	// "nodeA". When Kubernetes issues a command to the storage system to attach a volume to a specific
	// node, it can use this field to refer to the node name using the ID that the storage system will
	// understand, e.g. "nodeA" instead of "node1". This field is required.
	NodeID string `pulumi:"nodeID"`

	// topologyKeys is the list of keys supported by the driver. When a driver is initialized on a
	// cluster, it provides a set of topology keys that it understands (e.g. "company.com/zone",
	// "company.com/region"). When a driver is initialized on a node, it provides the same topology
	// keys along with values. Kubelet will expose these topology keys as labels on its own node
	// object. When Kubernetes does topology aware provisioning, it can use this list to determine
	// which labels it should retrieve from the node object and pass back to the driver. It is possible
	// for different nodes to use different topology keys. This can be empty if driver does not support
	// topology.
	TopologyKeys []string `pulumi:"topologyKeys"`

}

var _CSINodeDriverType = reflect.TypeOf((*CSINodeDriver)(nil)).Elem()

// CSINodeDriverInput represents an input type that resolves to a CSINodeDriver.
type CSINodeDriverInput interface {
	ElementType() reflect.Type

	ToCSINodeDriverOutput() CSINodeDriverOutput
	ToCSINodeDriverOutputWithContext(ctx context.Context) CSINodeDriverOutput
}

// CSINodeDriverArgs is a CSINodeDriverInput whose fields are all Input types.
type CSINodeDriverArgs struct {
	// This is the name of the CSI driver that this object refers to. This MUST be the same name
	// returned by the CSI GetPluginName() call for that driver.
	Name pulumi.StringInput `pulumi:"name"`

	// nodeID of the node from the driver point of view. This field enables Kubernetes to communicate
	// with storage systems that do not share the same nomenclature for nodes. For example, Kubernetes
	// may refer to a given node as "node1", but the storage system may refer to the same node as
	// "nodeA". When Kubernetes issues a command to the storage system to attach a volume to a specific
	// node, it can use this field to refer to the node name using the ID that the storage system will
	// understand, e.g. "nodeA" instead of "node1". This field is required.
	NodeID pulumi.StringInput `pulumi:"nodeID"`

	// allocatable represents the volume resources of a node that are available for scheduling.
	Allocatable VolumeNodeResourcesInput `pulumi:"allocatable"`

	// topologyKeys is the list of keys supported by the driver. When a driver is initialized on a
	// cluster, it provides a set of topology keys that it understands (e.g. "company.com/zone",
	// "company.com/region"). When a driver is initialized on a node, it provides the same topology
	// keys along with values. Kubelet will expose these topology keys as labels on its own node
	// object. When Kubernetes does topology aware provisioning, it can use this list to determine
	// which labels it should retrieve from the node object and pass back to the driver. It is possible
	// for different nodes to use different topology keys. This can be empty if driver does not support
	// topology.
	TopologyKeys pulumi.StringArrayInput `pulumi:"topologyKeys"`

}

func (a CSINodeDriverArgs) ElementType() reflect.Type {
	return _CSINodeDriverType
}

func (a CSINodeDriverArgs) ToCSINodeDriverOutput() CSINodeDriverOutput {
	return pulumi.ToOutput(a).(CSINodeDriverOutput)
}

func (a CSINodeDriverArgs) ToCSINodeDriverOutputWithContext(ctx context.Context) CSINodeDriverOutput {
	return pulumi.ToOutputWithContext(ctx, a).(CSINodeDriverOutput)
}

// CSINodeDriverOutput is an output type that resolves to a Input.
type CSINodeDriverOutput struct { *pulumi.OutputState }

func init() { pulumi.RegisterOutputType(CSINodeDriverOutput{}) }

func (CSINodeDriverOutput) ElementType() reflect.Type {
	return _CSINodeDriverType
}

func (o CSINodeDriverOutput) Allocatable() VolumeNodeResourcesOutput {
	return o.Apply(func(v CSINodeDriver) *VolumeNodeResources {
		return v.Allocatable
	}).(VolumeNodeResourcesOutput)
}

func (o CSINodeDriverOutput) Name() pulumi.StringOutput {
	return o.Apply(func(v CSINodeDriver) string {
		return v.Name
	}).(pulumi.StringOutput)
}

func (o CSINodeDriverOutput) NodeID() pulumi.StringOutput {
	return o.Apply(func(v CSINodeDriver) string {
		return v.NodeID
	}).(pulumi.StringOutput)
}

func (o CSINodeDriverOutput) TopologyKeys() pulumi.StringArrayOutput {
	return o.Apply(func(v CSINodeDriver) []string {
		return v.TopologyKeys
	}).(pulumi.StringArrayOutput)
}

var _CSINodeDriverArrayType = reflect.TypeOf((*[]CSINodeDriver)(nil)).Elem()

type CSINodeDriverArrayInput interface {
	ElementType() reflect.Type

	ToCSINodeDriverArrayOutput() CSINodeDriverArrayOutput
	ToCSINodeDriverArrayOutputWithContext(ctx context.Context) CSINodeDriverArrayOutput
}

type CSINodeDriverArray []CSINodeDriverInput

func (a CSINodeDriverArray) ElementType() reflect.Type {
	return _CSINodeDriverArrayType
}

func (a CSINodeDriverArray) ToCSINodeDriverArrayOutput() CSINodeDriverArrayOutput {
	return pulumi.ToOutput(a).(CSINodeDriverArrayOutput)
}

func (a CSINodeDriverArray) ToCSINodeDriverArrayOutputWithContext(ctx context.Context) CSINodeDriverArrayOutput {
	return pulumi.ToOutputWithContext(ctx, a).(CSINodeDriverArrayOutput)
}

type CSINodeDriverArrayOutput struct { *pulumi.OutputState }

func init() { pulumi.RegisterOutputType(CSINodeDriverArrayOutput{}) }

func (CSINodeDriverArrayOutput) ElementType() reflect.Type {
	return _CSINodeDriverArrayType
}

func (o CSINodeDriverArrayOutput) Index(i pulumi.IntInput) CSINodeDriverOutput {
	return pulumi.All(o, i).Apply(func(vs []interface{}) CSINodeDriver {
		return vs[0].([]CSINodeDriver)[vs[1].(int)]
	}).(CSINodeDriverOutput)
}
