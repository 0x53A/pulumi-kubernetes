// *** WARNING: this file was generated by the Pulumi Kubernetes codegen tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v1alpha1

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/go/pulumi"
	coreV1 "github.com/pulumi/pulumi-kubernetes/sdk/go/kubernetes/core/v1"
)

// Endpoint represents a single logical "backend" implementing a service.
type Endpoint struct {
	// addresses of this endpoint. The contents of this field are interpreted according to the
	// corresponding EndpointSlice addressType field. This allows for cases like dual-stack (IPv4 and
	// IPv6) networking. Consumers (e.g. kube-proxy) must handle different types of addresses in the
	// context of their own capabilities. This must contain at least one address but no more than 100.
	Addresses []string `pulumi:"addresses"`

	// conditions contains information about the current status of the endpoint.
	Conditions *EndpointConditions `pulumi:"conditions"`

	// hostname of this endpoint. This field may be used by consumers of endpoints to distinguish
	// endpoints from each other (e.g. in DNS names). Multiple endpoints which use the same hostname
	// should be considered fungible (e.g. multiple A values in DNS). Must pass DNS Label (RFC 1123)
	// validation.
	Hostname *string `pulumi:"hostname"`

	// targetRef is a reference to a Kubernetes object that represents this endpoint.
	TargetRef *coreV1.ObjectReference `pulumi:"targetRef"`

	// topology contains arbitrary topology information associated with the endpoint. These key/value
	// pairs must conform with the label format.
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels Topology may include a
	// maximum of 16 key/value pairs. This includes, but is not limited to the following well known
	// keys: * kubernetes.io/hostname: the value indicates the hostname of the node
	//   where the endpoint is located. This should match the corresponding
	//   node label.
	// * topology.kubernetes.io/zone: the value indicates the zone where the
	//   endpoint is located. This should match the corresponding node label.
	// * topology.kubernetes.io/region: the value indicates the region where the
	//   endpoint is located. This should match the corresponding node label.
	Topology map[string]string `pulumi:"topology"`

}

var _EndpointType = reflect.TypeOf((*Endpoint)(nil)).Elem()

// EndpointInput represents an input type that resolves to a Endpoint.
type EndpointInput interface {
	ElementType() reflect.Type

	ToEndpointOutput() EndpointOutput
	ToEndpointOutputWithContext(ctx context.Context) EndpointOutput
}

// EndpointArgs is a EndpointInput whose fields are all Input types.
type EndpointArgs struct {
	// addresses of this endpoint. The contents of this field are interpreted according to the
	// corresponding EndpointSlice addressType field. This allows for cases like dual-stack (IPv4 and
	// IPv6) networking. Consumers (e.g. kube-proxy) must handle different types of addresses in the
	// context of their own capabilities. This must contain at least one address but no more than 100.
	Addresses pulumi.StringArrayInput `pulumi:"addresses"`

	// conditions contains information about the current status of the endpoint.
	Conditions EndpointConditionsInput `pulumi:"conditions"`

	// hostname of this endpoint. This field may be used by consumers of endpoints to distinguish
	// endpoints from each other (e.g. in DNS names). Multiple endpoints which use the same hostname
	// should be considered fungible (e.g. multiple A values in DNS). Must pass DNS Label (RFC 1123)
	// validation.
	Hostname pulumi.StringInput `pulumi:"hostname"`

	// targetRef is a reference to a Kubernetes object that represents this endpoint.
	TargetRef coreV1.ObjectReferenceInput `pulumi:"targetRef"`

	// topology contains arbitrary topology information associated with the endpoint. These key/value
	// pairs must conform with the label format.
	// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels Topology may include a
	// maximum of 16 key/value pairs. This includes, but is not limited to the following well known
	// keys: * kubernetes.io/hostname: the value indicates the hostname of the node
	//   where the endpoint is located. This should match the corresponding
	//   node label.
	// * topology.kubernetes.io/zone: the value indicates the zone where the
	//   endpoint is located. This should match the corresponding node label.
	// * topology.kubernetes.io/region: the value indicates the region where the
	//   endpoint is located. This should match the corresponding node label.
	Topology pulumi.StringMapInput `pulumi:"topology"`

}

func (a EndpointArgs) ElementType() reflect.Type {
	return _EndpointType
}

func (a EndpointArgs) ToEndpointOutput() EndpointOutput {
	return pulumi.ToOutput(a).(EndpointOutput)
}

func (a EndpointArgs) ToEndpointOutputWithContext(ctx context.Context) EndpointOutput {
	return pulumi.ToOutputWithContext(ctx, a).(EndpointOutput)
}

// EndpointOutput is an output type that resolves to a Input.
type EndpointOutput struct { *pulumi.OutputState }

func init() { pulumi.RegisterOutputType(EndpointOutput{}) }

func (EndpointOutput) ElementType() reflect.Type {
	return _EndpointType
}

func (o EndpointOutput) Addresses() pulumi.StringArrayOutput {
	return o.Apply(func(v Endpoint) []string {
		return v.Addresses
	}).(pulumi.StringArrayOutput)
}

func (o EndpointOutput) Conditions() EndpointConditionsOutput {
	return o.Apply(func(v Endpoint) *EndpointConditions {
		return v.Conditions
	}).(EndpointConditionsOutput)
}

func (o EndpointOutput) Hostname() pulumi.StringOutput {
	return o.Apply(func(v Endpoint) *string {
		return v.Hostname
	}).(pulumi.StringOutput)
}

func (o EndpointOutput) TargetRef() coreV1.ObjectReferenceOutput {
	return o.Apply(func(v Endpoint) *coreV1.ObjectReference {
		return v.TargetRef
	}).(coreV1.ObjectReferenceOutput)
}

func (o EndpointOutput) Topology() pulumi.StringMapOutput {
	return o.Apply(func(v Endpoint) map[string]string {
		return v.Topology
	}).(pulumi.StringMapOutput)
}

var _EndpointArrayType = reflect.TypeOf((*[]Endpoint)(nil)).Elem()

type EndpointArrayInput interface {
	ElementType() reflect.Type

	ToEndpointArrayOutput() EndpointArrayOutput
	ToEndpointArrayOutputWithContext(ctx context.Context) EndpointArrayOutput
}

type EndpointArray []EndpointInput

func (a EndpointArray) ElementType() reflect.Type {
	return _EndpointArrayType
}

func (a EndpointArray) ToEndpointArrayOutput() EndpointArrayOutput {
	return pulumi.ToOutput(a).(EndpointArrayOutput)
}

func (a EndpointArray) ToEndpointArrayOutputWithContext(ctx context.Context) EndpointArrayOutput {
	return pulumi.ToOutputWithContext(ctx, a).(EndpointArrayOutput)
}

type EndpointArrayOutput struct { *pulumi.OutputState }

func init() { pulumi.RegisterOutputType(EndpointArrayOutput{}) }

func (EndpointArrayOutput) ElementType() reflect.Type {
	return _EndpointArrayType
}

func (o EndpointArrayOutput) Index(i pulumi.IntInput) EndpointOutput {
	return pulumi.All(o, i).Apply(func(vs []interface{}) Endpoint {
		return vs[0].([]Endpoint)[vs[1].(int)]
	}).(EndpointOutput)
}
