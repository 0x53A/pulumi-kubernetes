// *** WARNING: this file was generated by the Pulumi Kubernetes codegen tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v1

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/go/pulumi"
)

// PersistentVolumeSpec is the specification of a persistent volume.
type PersistentVolumeSpec struct {
	// AccessModes contains all ways the volume can be mounted. More info:
	// https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes
	AccessModes []string `pulumi:"accessModes"`

	// AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host
	// machine and then exposed to the pod. More info:
	// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
	AwsElasticBlockStore *AWSElasticBlockStoreVolumeSource `pulumi:"awsElasticBlockStore"`

	// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
	AzureDisk *AzureDiskVolumeSource `pulumi:"azureDisk"`

	// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
	AzureFile *AzureFilePersistentVolumeSource `pulumi:"azureFile"`

	// A description of the persistent volume's resources and capacity. More info:
	// https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
	Capacity map[string]string `pulumi:"capacity"`

	// CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
	Cephfs *CephFSPersistentVolumeSource `pulumi:"cephfs"`

	// Cinder represents a cinder volume attached and mounted on kubelets host machine. More info:
	// https://examples.k8s.io/mysql-cinder-pd/README.md
	Cinder *CinderPersistentVolumeSource `pulumi:"cinder"`

	// ClaimRef is part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim.
	// Expected to be non-nil when bound. claim.VolumeName is the authoritative bind between PV and
	// PVC. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding
	ClaimRef *ObjectReference `pulumi:"claimRef"`

	// CSI represents storage that is handled by an external CSI driver (Beta feature).
	Csi *CSIPersistentVolumeSource `pulumi:"csi"`

	// FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then
	// exposed to the pod.
	Fc *FCVolumeSource `pulumi:"fc"`

	// FlexVolume represents a generic volume resource that is provisioned/attached using an exec based
	// plugin.
	FlexVolume *FlexPersistentVolumeSource `pulumi:"flexVolume"`

	// Flocker represents a Flocker volume attached to a kubelet's host machine and exposed to the pod
	// for its usage. This depends on the Flocker control service being running
	Flocker *FlockerVolumeSource `pulumi:"flocker"`

	// GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine
	// and then exposed to the pod. Provisioned by an admin. More info:
	// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
	GcePersistentDisk *GCEPersistentDiskVolumeSource `pulumi:"gcePersistentDisk"`

	// Glusterfs represents a Glusterfs volume that is attached to a host and exposed to the pod.
	// Provisioned by an admin. More info: https://examples.k8s.io/volumes/glusterfs/README.md
	Glusterfs *GlusterfsPersistentVolumeSource `pulumi:"glusterfs"`

	// HostPath represents a directory on the host. Provisioned by a developer or tester. This is
	// useful for single-node development and testing only! On-host storage is not supported in any way
	// and WILL NOT WORK in a multi-node cluster. More info:
	// https://kubernetes.io/docs/concepts/storage/volumes#hostpath
	HostPath *HostPathVolumeSource `pulumi:"hostPath"`

	// ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then
	// exposed to the pod. Provisioned by an admin.
	Iscsi *ISCSIPersistentVolumeSource `pulumi:"iscsi"`

	// Local represents directly-attached storage with node affinity
	Local *LocalVolumeSource `pulumi:"local"`

	// A list of mount options, e.g. ["ro", "soft"]. Not validated - mount will simply fail if one is
	// invalid. More info:
	// https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options
	MountOptions []string `pulumi:"mountOptions"`

	// NFS represents an NFS mount on the host. Provisioned by an admin. More info:
	// https://kubernetes.io/docs/concepts/storage/volumes#nfs
	Nfs *NFSVolumeSource `pulumi:"nfs"`

	// NodeAffinity defines constraints that limit what nodes this volume can be accessed from. This
	// field influences the scheduling of pods that use this volume.
	NodeAffinity *VolumeNodeAffinity `pulumi:"nodeAffinity"`

	// What happens to a persistent volume when released from its claim. Valid options are Retain
	// (default for manually created PersistentVolumes), Delete (default for dynamically provisioned
	// PersistentVolumes), and Recycle (deprecated). Recycle must be supported by the volume plugin
	// underlying this PersistentVolume. More info:
	// https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming
	PersistentVolumeReclaimPolicy *string `pulumi:"persistentVolumeReclaimPolicy"`

	// PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on
	// kubelets host machine
	PhotonPersistentDisk *PhotonPersistentDiskVolumeSource `pulumi:"photonPersistentDisk"`

	// PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
	PortworxVolume *PortworxVolumeSource `pulumi:"portworxVolume"`

	// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
	Quobyte *QuobyteVolumeSource `pulumi:"quobyte"`

	// RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info:
	// https://examples.k8s.io/volumes/rbd/README.md
	Rbd *RBDPersistentVolumeSource `pulumi:"rbd"`

	// ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
	ScaleIO *ScaleIOPersistentVolumeSource `pulumi:"scaleIO"`

	// Name of StorageClass to which this persistent volume belongs. Empty value means that this volume
	// does not belong to any StorageClass.
	StorageClassName *string `pulumi:"storageClassName"`

	// StorageOS represents a StorageOS volume that is attached to the kubelet's host machine and
	// mounted into the pod More info: https://examples.k8s.io/volumes/storageos/README.md
	Storageos *StorageOSPersistentVolumeSource `pulumi:"storageos"`

	// volumeMode defines if a volume is intended to be used with a formatted filesystem or to remain
	// in raw block state. Value of Filesystem is implied when not included in spec. This is a beta
	// feature.
	VolumeMode *string `pulumi:"volumeMode"`

	// VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
	VsphereVolume *VsphereVirtualDiskVolumeSource `pulumi:"vsphereVolume"`

}

var _PersistentVolumeSpecType = reflect.TypeOf((*PersistentVolumeSpec)(nil)).Elem()

// PersistentVolumeSpecInput represents an input type that resolves to a PersistentVolumeSpec.
type PersistentVolumeSpecInput interface {
	ElementType() reflect.Type

	ToPersistentVolumeSpecOutput() PersistentVolumeSpecOutput
	ToPersistentVolumeSpecOutputWithContext(ctx context.Context) PersistentVolumeSpecOutput
}

// PersistentVolumeSpecArgs is a PersistentVolumeSpecInput whose fields are all Input types.
type PersistentVolumeSpecArgs struct {
	// AccessModes contains all ways the volume can be mounted. More info:
	// https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes
	AccessModes pulumi.StringArrayInput `pulumi:"accessModes"`

	// AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host
	// machine and then exposed to the pod. More info:
	// https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
	AwsElasticBlockStore AWSElasticBlockStoreVolumeSourceInput `pulumi:"awsElasticBlockStore"`

	// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
	AzureDisk AzureDiskVolumeSourceInput `pulumi:"azureDisk"`

	// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
	AzureFile AzureFilePersistentVolumeSourceInput `pulumi:"azureFile"`

	// A description of the persistent volume's resources and capacity. More info:
	// https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
	Capacity pulumi.StringMapInput `pulumi:"capacity"`

	// CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
	Cephfs CephFSPersistentVolumeSourceInput `pulumi:"cephfs"`

	// Cinder represents a cinder volume attached and mounted on kubelets host machine. More info:
	// https://examples.k8s.io/mysql-cinder-pd/README.md
	Cinder CinderPersistentVolumeSourceInput `pulumi:"cinder"`

	// ClaimRef is part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim.
	// Expected to be non-nil when bound. claim.VolumeName is the authoritative bind between PV and
	// PVC. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding
	ClaimRef ObjectReferenceInput `pulumi:"claimRef"`

	// CSI represents storage that is handled by an external CSI driver (Beta feature).
	Csi CSIPersistentVolumeSourceInput `pulumi:"csi"`

	// FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then
	// exposed to the pod.
	Fc FCVolumeSourceInput `pulumi:"fc"`

	// FlexVolume represents a generic volume resource that is provisioned/attached using an exec based
	// plugin.
	FlexVolume FlexPersistentVolumeSourceInput `pulumi:"flexVolume"`

	// Flocker represents a Flocker volume attached to a kubelet's host machine and exposed to the pod
	// for its usage. This depends on the Flocker control service being running
	Flocker FlockerVolumeSourceInput `pulumi:"flocker"`

	// GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine
	// and then exposed to the pod. Provisioned by an admin. More info:
	// https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
	GcePersistentDisk GCEPersistentDiskVolumeSourceInput `pulumi:"gcePersistentDisk"`

	// Glusterfs represents a Glusterfs volume that is attached to a host and exposed to the pod.
	// Provisioned by an admin. More info: https://examples.k8s.io/volumes/glusterfs/README.md
	Glusterfs GlusterfsPersistentVolumeSourceInput `pulumi:"glusterfs"`

	// HostPath represents a directory on the host. Provisioned by a developer or tester. This is
	// useful for single-node development and testing only! On-host storage is not supported in any way
	// and WILL NOT WORK in a multi-node cluster. More info:
	// https://kubernetes.io/docs/concepts/storage/volumes#hostpath
	HostPath HostPathVolumeSourceInput `pulumi:"hostPath"`

	// ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then
	// exposed to the pod. Provisioned by an admin.
	Iscsi ISCSIPersistentVolumeSourceInput `pulumi:"iscsi"`

	// Local represents directly-attached storage with node affinity
	Local LocalVolumeSourceInput `pulumi:"local"`

	// A list of mount options, e.g. ["ro", "soft"]. Not validated - mount will simply fail if one is
	// invalid. More info:
	// https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options
	MountOptions pulumi.StringArrayInput `pulumi:"mountOptions"`

	// NFS represents an NFS mount on the host. Provisioned by an admin. More info:
	// https://kubernetes.io/docs/concepts/storage/volumes#nfs
	Nfs NFSVolumeSourceInput `pulumi:"nfs"`

	// NodeAffinity defines constraints that limit what nodes this volume can be accessed from. This
	// field influences the scheduling of pods that use this volume.
	NodeAffinity VolumeNodeAffinityInput `pulumi:"nodeAffinity"`

	// What happens to a persistent volume when released from its claim. Valid options are Retain
	// (default for manually created PersistentVolumes), Delete (default for dynamically provisioned
	// PersistentVolumes), and Recycle (deprecated). Recycle must be supported by the volume plugin
	// underlying this PersistentVolume. More info:
	// https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming
	PersistentVolumeReclaimPolicy pulumi.StringInput `pulumi:"persistentVolumeReclaimPolicy"`

	// PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on
	// kubelets host machine
	PhotonPersistentDisk PhotonPersistentDiskVolumeSourceInput `pulumi:"photonPersistentDisk"`

	// PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
	PortworxVolume PortworxVolumeSourceInput `pulumi:"portworxVolume"`

	// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
	Quobyte QuobyteVolumeSourceInput `pulumi:"quobyte"`

	// RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info:
	// https://examples.k8s.io/volumes/rbd/README.md
	Rbd RBDPersistentVolumeSourceInput `pulumi:"rbd"`

	// ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
	ScaleIO ScaleIOPersistentVolumeSourceInput `pulumi:"scaleIO"`

	// Name of StorageClass to which this persistent volume belongs. Empty value means that this volume
	// does not belong to any StorageClass.
	StorageClassName pulumi.StringInput `pulumi:"storageClassName"`

	// StorageOS represents a StorageOS volume that is attached to the kubelet's host machine and
	// mounted into the pod More info: https://examples.k8s.io/volumes/storageos/README.md
	Storageos StorageOSPersistentVolumeSourceInput `pulumi:"storageos"`

	// volumeMode defines if a volume is intended to be used with a formatted filesystem or to remain
	// in raw block state. Value of Filesystem is implied when not included in spec. This is a beta
	// feature.
	VolumeMode pulumi.StringInput `pulumi:"volumeMode"`

	// VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
	VsphereVolume VsphereVirtualDiskVolumeSourceInput `pulumi:"vsphereVolume"`

}

func (a PersistentVolumeSpecArgs) ElementType() reflect.Type {
	return _PersistentVolumeSpecType
}

func (a PersistentVolumeSpecArgs) ToPersistentVolumeSpecOutput() PersistentVolumeSpecOutput {
	return pulumi.ToOutput(a).(PersistentVolumeSpecOutput)
}

func (a PersistentVolumeSpecArgs) ToPersistentVolumeSpecOutputWithContext(ctx context.Context) PersistentVolumeSpecOutput {
	return pulumi.ToOutputWithContext(ctx, a).(PersistentVolumeSpecOutput)
}

// PersistentVolumeSpecOutput is an output type that resolves to a Input.
type PersistentVolumeSpecOutput struct { *pulumi.OutputState }

func init() { pulumi.RegisterOutputType(PersistentVolumeSpecOutput{}) }

func (PersistentVolumeSpecOutput) ElementType() reflect.Type {
	return _PersistentVolumeSpecType
}

func (o PersistentVolumeSpecOutput) AccessModes() pulumi.StringArrayOutput {
	return o.Apply(func(v PersistentVolumeSpec) []string {
		return v.AccessModes
	}).(pulumi.StringArrayOutput)
}

func (o PersistentVolumeSpecOutput) AwsElasticBlockStore() AWSElasticBlockStoreVolumeSourceOutput {
	return o.Apply(func(v PersistentVolumeSpec) *AWSElasticBlockStoreVolumeSource {
		return v.AwsElasticBlockStore
	}).(AWSElasticBlockStoreVolumeSourceOutput)
}

func (o PersistentVolumeSpecOutput) AzureDisk() AzureDiskVolumeSourceOutput {
	return o.Apply(func(v PersistentVolumeSpec) *AzureDiskVolumeSource {
		return v.AzureDisk
	}).(AzureDiskVolumeSourceOutput)
}

func (o PersistentVolumeSpecOutput) AzureFile() AzureFilePersistentVolumeSourceOutput {
	return o.Apply(func(v PersistentVolumeSpec) *AzureFilePersistentVolumeSource {
		return v.AzureFile
	}).(AzureFilePersistentVolumeSourceOutput)
}

func (o PersistentVolumeSpecOutput) Capacity() pulumi.StringMapOutput {
	return o.Apply(func(v PersistentVolumeSpec) map[string]string {
		return v.Capacity
	}).(pulumi.StringMapOutput)
}

func (o PersistentVolumeSpecOutput) Cephfs() CephFSPersistentVolumeSourceOutput {
	return o.Apply(func(v PersistentVolumeSpec) *CephFSPersistentVolumeSource {
		return v.Cephfs
	}).(CephFSPersistentVolumeSourceOutput)
}

func (o PersistentVolumeSpecOutput) Cinder() CinderPersistentVolumeSourceOutput {
	return o.Apply(func(v PersistentVolumeSpec) *CinderPersistentVolumeSource {
		return v.Cinder
	}).(CinderPersistentVolumeSourceOutput)
}

func (o PersistentVolumeSpecOutput) ClaimRef() ObjectReferenceOutput {
	return o.Apply(func(v PersistentVolumeSpec) *ObjectReference {
		return v.ClaimRef
	}).(ObjectReferenceOutput)
}

func (o PersistentVolumeSpecOutput) Csi() CSIPersistentVolumeSourceOutput {
	return o.Apply(func(v PersistentVolumeSpec) *CSIPersistentVolumeSource {
		return v.Csi
	}).(CSIPersistentVolumeSourceOutput)
}

func (o PersistentVolumeSpecOutput) Fc() FCVolumeSourceOutput {
	return o.Apply(func(v PersistentVolumeSpec) *FCVolumeSource {
		return v.Fc
	}).(FCVolumeSourceOutput)
}

func (o PersistentVolumeSpecOutput) FlexVolume() FlexPersistentVolumeSourceOutput {
	return o.Apply(func(v PersistentVolumeSpec) *FlexPersistentVolumeSource {
		return v.FlexVolume
	}).(FlexPersistentVolumeSourceOutput)
}

func (o PersistentVolumeSpecOutput) Flocker() FlockerVolumeSourceOutput {
	return o.Apply(func(v PersistentVolumeSpec) *FlockerVolumeSource {
		return v.Flocker
	}).(FlockerVolumeSourceOutput)
}

func (o PersistentVolumeSpecOutput) GcePersistentDisk() GCEPersistentDiskVolumeSourceOutput {
	return o.Apply(func(v PersistentVolumeSpec) *GCEPersistentDiskVolumeSource {
		return v.GcePersistentDisk
	}).(GCEPersistentDiskVolumeSourceOutput)
}

func (o PersistentVolumeSpecOutput) Glusterfs() GlusterfsPersistentVolumeSourceOutput {
	return o.Apply(func(v PersistentVolumeSpec) *GlusterfsPersistentVolumeSource {
		return v.Glusterfs
	}).(GlusterfsPersistentVolumeSourceOutput)
}

func (o PersistentVolumeSpecOutput) HostPath() HostPathVolumeSourceOutput {
	return o.Apply(func(v PersistentVolumeSpec) *HostPathVolumeSource {
		return v.HostPath
	}).(HostPathVolumeSourceOutput)
}

func (o PersistentVolumeSpecOutput) Iscsi() ISCSIPersistentVolumeSourceOutput {
	return o.Apply(func(v PersistentVolumeSpec) *ISCSIPersistentVolumeSource {
		return v.Iscsi
	}).(ISCSIPersistentVolumeSourceOutput)
}

func (o PersistentVolumeSpecOutput) Local() LocalVolumeSourceOutput {
	return o.Apply(func(v PersistentVolumeSpec) *LocalVolumeSource {
		return v.Local
	}).(LocalVolumeSourceOutput)
}

func (o PersistentVolumeSpecOutput) MountOptions() pulumi.StringArrayOutput {
	return o.Apply(func(v PersistentVolumeSpec) []string {
		return v.MountOptions
	}).(pulumi.StringArrayOutput)
}

func (o PersistentVolumeSpecOutput) Nfs() NFSVolumeSourceOutput {
	return o.Apply(func(v PersistentVolumeSpec) *NFSVolumeSource {
		return v.Nfs
	}).(NFSVolumeSourceOutput)
}

func (o PersistentVolumeSpecOutput) NodeAffinity() VolumeNodeAffinityOutput {
	return o.Apply(func(v PersistentVolumeSpec) *VolumeNodeAffinity {
		return v.NodeAffinity
	}).(VolumeNodeAffinityOutput)
}

func (o PersistentVolumeSpecOutput) PersistentVolumeReclaimPolicy() pulumi.StringOutput {
	return o.Apply(func(v PersistentVolumeSpec) *string {
		return v.PersistentVolumeReclaimPolicy
	}).(pulumi.StringOutput)
}

func (o PersistentVolumeSpecOutput) PhotonPersistentDisk() PhotonPersistentDiskVolumeSourceOutput {
	return o.Apply(func(v PersistentVolumeSpec) *PhotonPersistentDiskVolumeSource {
		return v.PhotonPersistentDisk
	}).(PhotonPersistentDiskVolumeSourceOutput)
}

func (o PersistentVolumeSpecOutput) PortworxVolume() PortworxVolumeSourceOutput {
	return o.Apply(func(v PersistentVolumeSpec) *PortworxVolumeSource {
		return v.PortworxVolume
	}).(PortworxVolumeSourceOutput)
}

func (o PersistentVolumeSpecOutput) Quobyte() QuobyteVolumeSourceOutput {
	return o.Apply(func(v PersistentVolumeSpec) *QuobyteVolumeSource {
		return v.Quobyte
	}).(QuobyteVolumeSourceOutput)
}

func (o PersistentVolumeSpecOutput) Rbd() RBDPersistentVolumeSourceOutput {
	return o.Apply(func(v PersistentVolumeSpec) *RBDPersistentVolumeSource {
		return v.Rbd
	}).(RBDPersistentVolumeSourceOutput)
}

func (o PersistentVolumeSpecOutput) ScaleIO() ScaleIOPersistentVolumeSourceOutput {
	return o.Apply(func(v PersistentVolumeSpec) *ScaleIOPersistentVolumeSource {
		return v.ScaleIO
	}).(ScaleIOPersistentVolumeSourceOutput)
}

func (o PersistentVolumeSpecOutput) StorageClassName() pulumi.StringOutput {
	return o.Apply(func(v PersistentVolumeSpec) *string {
		return v.StorageClassName
	}).(pulumi.StringOutput)
}

func (o PersistentVolumeSpecOutput) Storageos() StorageOSPersistentVolumeSourceOutput {
	return o.Apply(func(v PersistentVolumeSpec) *StorageOSPersistentVolumeSource {
		return v.Storageos
	}).(StorageOSPersistentVolumeSourceOutput)
}

func (o PersistentVolumeSpecOutput) VolumeMode() pulumi.StringOutput {
	return o.Apply(func(v PersistentVolumeSpec) *string {
		return v.VolumeMode
	}).(pulumi.StringOutput)
}

func (o PersistentVolumeSpecOutput) VsphereVolume() VsphereVirtualDiskVolumeSourceOutput {
	return o.Apply(func(v PersistentVolumeSpec) *VsphereVirtualDiskVolumeSource {
		return v.VsphereVolume
	}).(VsphereVirtualDiskVolumeSourceOutput)
}

