// *** WARNING: this file was generated by the Pulumi Kubernetes codegen tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v1

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/go/pulumi"
)

// An EphemeralContainer is a container that may be added temporarily to an existing pod for
// user-initiated activities such as debugging. Ephemeral containers have no resource or scheduling
// guarantees, and they will not be restarted when they exit or when a pod is removed or restarted.
// If an ephemeral container causes a pod to exceed its resource allocation, the pod may be evicted.
// Ephemeral containers may not be added by directly updating the pod spec. They must be added via
// the pod's ephemeralcontainers subresource, and they will appear in the pod spec once added. This
// is an alpha feature enabled by the EphemeralContainers feature flag.
type EphemeralContainer struct {
	// Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable
	// references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be
	// resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be
	// escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
	// regardless of whether the variable exists or not. Cannot be updated. More info:
	// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
	Args []string `pulumi:"args"`

	// Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is
	// not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If
	// a variable cannot be resolved, the reference in the input string will be unchanged. The
	// $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will
	// never be expanded, regardless of whether the variable exists or not. Cannot be updated. More
	// info:
	// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
	Command []string `pulumi:"command"`

	// List of environment variables to set in the container. Cannot be updated.
	Env []EnvVar `pulumi:"env"`

	// List of sources to populate environment variables in the container. The keys defined within a
	// source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container
	// is starting. When a key exists in multiple sources, the value associated with the last source
	// will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot
	// be updated.
	EnvFrom []EnvFromSource `pulumi:"envFrom"`

	// Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images
	Image *string `pulumi:"image"`

	// Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is
	// specified, or IfNotPresent otherwise. Cannot be updated. More info:
	// https://kubernetes.io/docs/concepts/containers/images#updating-images
	ImagePullPolicy *string `pulumi:"imagePullPolicy"`

	// Lifecycle is not allowed for ephemeral containers.
	Lifecycle *Lifecycle `pulumi:"lifecycle"`

	// Probes are not allowed for ephemeral containers.
	LivenessProbe *Probe `pulumi:"livenessProbe"`

	// Name of the ephemeral container specified as a DNS_LABEL. This name must be unique among all
	// containers, init containers and ephemeral containers.
	Name string `pulumi:"name"`

	// Ports are not allowed for ephemeral containers.
	Ports []ContainerPort `pulumi:"ports"`

	// Probes are not allowed for ephemeral containers.
	ReadinessProbe *Probe `pulumi:"readinessProbe"`

	// Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources
	// already allocated to the pod.
	Resources *ResourceRequirements `pulumi:"resources"`

	// SecurityContext is not allowed for ephemeral containers.
	SecurityContext *SecurityContext `pulumi:"securityContext"`

	// Probes are not allowed for ephemeral containers.
	StartupProbe *Probe `pulumi:"startupProbe"`

	// Whether this container should allocate a buffer for stdin in the container runtime. If this is
	// not set, reads from stdin in the container will always result in EOF. Default is false.
	Stdin *bool `pulumi:"stdin"`

	// Whether the container runtime should close the stdin channel after it has been opened by a
	// single attach. When stdin is true the stdin stream will remain open across multiple attach
	// sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
	// first client attaches to stdin, and then remains open and accepts data until the client
	// disconnects, at which time stdin is closed and remains closed until the container is restarted.
	// If this flag is false, a container processes that reads from stdin will never receive an EOF.
	// Default is false
	StdinOnce *bool `pulumi:"stdinOnce"`

	// If set, the name of the container from PodSpec that this ephemeral container targets. The
	// ephemeral container will be run in the namespaces (IPC, PID, etc) of this container. If not set
	// then the ephemeral container is run in whatever namespaces are shared for the pod. Note that the
	// container runtime must support this feature.
	TargetContainerName *string `pulumi:"targetContainerName"`

	// Optional: Path at which the file to which the container's termination message will be written is
	// mounted into the container's filesystem. Message written is intended to be brief final status,
	// such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes.
	// The total message length across all containers will be limited to 12kb. Defaults to
	// /dev/termination-log. Cannot be updated.
	TerminationMessagePath *string `pulumi:"terminationMessagePath"`

	// Indicate how the termination message should be populated. File will use the contents of
	// terminationMessagePath to populate the container status message on both success and failure.
	// FallbackToLogsOnError will use the last chunk of container log output if the termination message
	// file is empty and the container exited with an error. The log output is limited to 2048 bytes or
	// 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
	TerminationMessagePolicy *string `pulumi:"terminationMessagePolicy"`

	// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
	// Default is false.
	Tty *bool `pulumi:"tty"`

	// volumeDevices is the list of block devices to be used by the container. This is a beta feature.
	VolumeDevices []VolumeDevice `pulumi:"volumeDevices"`

	// Pod volumes to mount into the container's filesystem. Cannot be updated.
	VolumeMounts []VolumeMount `pulumi:"volumeMounts"`

	// Container's working directory. If not specified, the container runtime's default will be used,
	// which might be configured in the container image. Cannot be updated.
	WorkingDir *string `pulumi:"workingDir"`

}

var _EphemeralContainerType = reflect.TypeOf((*EphemeralContainer)(nil)).Elem()

// EphemeralContainerInput represents an input type that resolves to a EphemeralContainer.
type EphemeralContainerInput interface {
	ElementType() reflect.Type

	ToEphemeralContainerOutput() EphemeralContainerOutput
	ToEphemeralContainerOutputWithContext(ctx context.Context) EphemeralContainerOutput
}

// EphemeralContainerArgs is a EphemeralContainerInput whose fields are all Input types.
type EphemeralContainerArgs struct {
	// Name of the ephemeral container specified as a DNS_LABEL. This name must be unique among all
	// containers, init containers and ephemeral containers.
	Name pulumi.StringInput `pulumi:"name"`

	// Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable
	// references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be
	// resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be
	// escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
	// regardless of whether the variable exists or not. Cannot be updated. More info:
	// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
	Args pulumi.StringArrayInput `pulumi:"args"`

	// Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is
	// not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If
	// a variable cannot be resolved, the reference in the input string will be unchanged. The
	// $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will
	// never be expanded, regardless of whether the variable exists or not. Cannot be updated. More
	// info:
	// https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
	Command pulumi.StringArrayInput `pulumi:"command"`

	// List of environment variables to set in the container. Cannot be updated.
	Env EnvVarArrayInput `pulumi:"env"`

	// List of sources to populate environment variables in the container. The keys defined within a
	// source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container
	// is starting. When a key exists in multiple sources, the value associated with the last source
	// will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot
	// be updated.
	EnvFrom EnvFromSourceArrayInput `pulumi:"envFrom"`

	// Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images
	Image pulumi.StringInput `pulumi:"image"`

	// Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is
	// specified, or IfNotPresent otherwise. Cannot be updated. More info:
	// https://kubernetes.io/docs/concepts/containers/images#updating-images
	ImagePullPolicy pulumi.StringInput `pulumi:"imagePullPolicy"`

	// Lifecycle is not allowed for ephemeral containers.
	Lifecycle LifecycleInput `pulumi:"lifecycle"`

	// Probes are not allowed for ephemeral containers.
	LivenessProbe ProbeInput `pulumi:"livenessProbe"`

	// Ports are not allowed for ephemeral containers.
	Ports ContainerPortArrayInput `pulumi:"ports"`

	// Probes are not allowed for ephemeral containers.
	ReadinessProbe ProbeInput `pulumi:"readinessProbe"`

	// Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources
	// already allocated to the pod.
	Resources ResourceRequirementsInput `pulumi:"resources"`

	// SecurityContext is not allowed for ephemeral containers.
	SecurityContext SecurityContextInput `pulumi:"securityContext"`

	// Probes are not allowed for ephemeral containers.
	StartupProbe ProbeInput `pulumi:"startupProbe"`

	// Whether this container should allocate a buffer for stdin in the container runtime. If this is
	// not set, reads from stdin in the container will always result in EOF. Default is false.
	Stdin pulumi.BoolInput `pulumi:"stdin"`

	// Whether the container runtime should close the stdin channel after it has been opened by a
	// single attach. When stdin is true the stdin stream will remain open across multiple attach
	// sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
	// first client attaches to stdin, and then remains open and accepts data until the client
	// disconnects, at which time stdin is closed and remains closed until the container is restarted.
	// If this flag is false, a container processes that reads from stdin will never receive an EOF.
	// Default is false
	StdinOnce pulumi.BoolInput `pulumi:"stdinOnce"`

	// If set, the name of the container from PodSpec that this ephemeral container targets. The
	// ephemeral container will be run in the namespaces (IPC, PID, etc) of this container. If not set
	// then the ephemeral container is run in whatever namespaces are shared for the pod. Note that the
	// container runtime must support this feature.
	TargetContainerName pulumi.StringInput `pulumi:"targetContainerName"`

	// Optional: Path at which the file to which the container's termination message will be written is
	// mounted into the container's filesystem. Message written is intended to be brief final status,
	// such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes.
	// The total message length across all containers will be limited to 12kb. Defaults to
	// /dev/termination-log. Cannot be updated.
	TerminationMessagePath pulumi.StringInput `pulumi:"terminationMessagePath"`

	// Indicate how the termination message should be populated. File will use the contents of
	// terminationMessagePath to populate the container status message on both success and failure.
	// FallbackToLogsOnError will use the last chunk of container log output if the termination message
	// file is empty and the container exited with an error. The log output is limited to 2048 bytes or
	// 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
	TerminationMessagePolicy pulumi.StringInput `pulumi:"terminationMessagePolicy"`

	// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
	// Default is false.
	Tty pulumi.BoolInput `pulumi:"tty"`

	// volumeDevices is the list of block devices to be used by the container. This is a beta feature.
	VolumeDevices VolumeDeviceArrayInput `pulumi:"volumeDevices"`

	// Pod volumes to mount into the container's filesystem. Cannot be updated.
	VolumeMounts VolumeMountArrayInput `pulumi:"volumeMounts"`

	// Container's working directory. If not specified, the container runtime's default will be used,
	// which might be configured in the container image. Cannot be updated.
	WorkingDir pulumi.StringInput `pulumi:"workingDir"`

}

func (a EphemeralContainerArgs) ElementType() reflect.Type {
	return _EphemeralContainerType
}

func (a EphemeralContainerArgs) ToEphemeralContainerOutput() EphemeralContainerOutput {
	return pulumi.ToOutput(a).(EphemeralContainerOutput)
}

func (a EphemeralContainerArgs) ToEphemeralContainerOutputWithContext(ctx context.Context) EphemeralContainerOutput {
	return pulumi.ToOutputWithContext(ctx, a).(EphemeralContainerOutput)
}

// EphemeralContainerOutput is an output type that resolves to a Input.
type EphemeralContainerOutput struct { *pulumi.OutputState }

func init() { pulumi.RegisterOutputType(EphemeralContainerOutput{}) }

func (EphemeralContainerOutput) ElementType() reflect.Type {
	return _EphemeralContainerType
}

func (o EphemeralContainerOutput) Args() pulumi.StringArrayOutput {
	return o.Apply(func(v EphemeralContainer) []string {
		return v.Args
	}).(pulumi.StringArrayOutput)
}

func (o EphemeralContainerOutput) Command() pulumi.StringArrayOutput {
	return o.Apply(func(v EphemeralContainer) []string {
		return v.Command
	}).(pulumi.StringArrayOutput)
}

func (o EphemeralContainerOutput) Env() EnvVarArrayOutput {
	return o.Apply(func(v EphemeralContainer) []EnvVar {
		return v.Env
	}).(EnvVarArrayOutput)
}

func (o EphemeralContainerOutput) EnvFrom() EnvFromSourceArrayOutput {
	return o.Apply(func(v EphemeralContainer) []EnvFromSource {
		return v.EnvFrom
	}).(EnvFromSourceArrayOutput)
}

func (o EphemeralContainerOutput) Image() pulumi.StringOutput {
	return o.Apply(func(v EphemeralContainer) *string {
		return v.Image
	}).(pulumi.StringOutput)
}

func (o EphemeralContainerOutput) ImagePullPolicy() pulumi.StringOutput {
	return o.Apply(func(v EphemeralContainer) *string {
		return v.ImagePullPolicy
	}).(pulumi.StringOutput)
}

func (o EphemeralContainerOutput) Lifecycle() LifecycleOutput {
	return o.Apply(func(v EphemeralContainer) *Lifecycle {
		return v.Lifecycle
	}).(LifecycleOutput)
}

func (o EphemeralContainerOutput) LivenessProbe() ProbeOutput {
	return o.Apply(func(v EphemeralContainer) *Probe {
		return v.LivenessProbe
	}).(ProbeOutput)
}

func (o EphemeralContainerOutput) Name() pulumi.StringOutput {
	return o.Apply(func(v EphemeralContainer) string {
		return v.Name
	}).(pulumi.StringOutput)
}

func (o EphemeralContainerOutput) Ports() ContainerPortArrayOutput {
	return o.Apply(func(v EphemeralContainer) []ContainerPort {
		return v.Ports
	}).(ContainerPortArrayOutput)
}

func (o EphemeralContainerOutput) ReadinessProbe() ProbeOutput {
	return o.Apply(func(v EphemeralContainer) *Probe {
		return v.ReadinessProbe
	}).(ProbeOutput)
}

func (o EphemeralContainerOutput) Resources() ResourceRequirementsOutput {
	return o.Apply(func(v EphemeralContainer) *ResourceRequirements {
		return v.Resources
	}).(ResourceRequirementsOutput)
}

func (o EphemeralContainerOutput) SecurityContext() SecurityContextOutput {
	return o.Apply(func(v EphemeralContainer) *SecurityContext {
		return v.SecurityContext
	}).(SecurityContextOutput)
}

func (o EphemeralContainerOutput) StartupProbe() ProbeOutput {
	return o.Apply(func(v EphemeralContainer) *Probe {
		return v.StartupProbe
	}).(ProbeOutput)
}

func (o EphemeralContainerOutput) Stdin() pulumi.BoolOutput {
	return o.Apply(func(v EphemeralContainer) *bool {
		return v.Stdin
	}).(pulumi.BoolOutput)
}

func (o EphemeralContainerOutput) StdinOnce() pulumi.BoolOutput {
	return o.Apply(func(v EphemeralContainer) *bool {
		return v.StdinOnce
	}).(pulumi.BoolOutput)
}

func (o EphemeralContainerOutput) TargetContainerName() pulumi.StringOutput {
	return o.Apply(func(v EphemeralContainer) *string {
		return v.TargetContainerName
	}).(pulumi.StringOutput)
}

func (o EphemeralContainerOutput) TerminationMessagePath() pulumi.StringOutput {
	return o.Apply(func(v EphemeralContainer) *string {
		return v.TerminationMessagePath
	}).(pulumi.StringOutput)
}

func (o EphemeralContainerOutput) TerminationMessagePolicy() pulumi.StringOutput {
	return o.Apply(func(v EphemeralContainer) *string {
		return v.TerminationMessagePolicy
	}).(pulumi.StringOutput)
}

func (o EphemeralContainerOutput) Tty() pulumi.BoolOutput {
	return o.Apply(func(v EphemeralContainer) *bool {
		return v.Tty
	}).(pulumi.BoolOutput)
}

func (o EphemeralContainerOutput) VolumeDevices() VolumeDeviceArrayOutput {
	return o.Apply(func(v EphemeralContainer) []VolumeDevice {
		return v.VolumeDevices
	}).(VolumeDeviceArrayOutput)
}

func (o EphemeralContainerOutput) VolumeMounts() VolumeMountArrayOutput {
	return o.Apply(func(v EphemeralContainer) []VolumeMount {
		return v.VolumeMounts
	}).(VolumeMountArrayOutput)
}

func (o EphemeralContainerOutput) WorkingDir() pulumi.StringOutput {
	return o.Apply(func(v EphemeralContainer) *string {
		return v.WorkingDir
	}).(pulumi.StringOutput)
}

var _EphemeralContainerArrayType = reflect.TypeOf((*[]EphemeralContainer)(nil)).Elem()

type EphemeralContainerArrayInput interface {
	ElementType() reflect.Type

	ToEphemeralContainerArrayOutput() EphemeralContainerArrayOutput
	ToEphemeralContainerArrayOutputWithContext(ctx context.Context) EphemeralContainerArrayOutput
}

type EphemeralContainerArray []EphemeralContainerInput

func (a EphemeralContainerArray) ElementType() reflect.Type {
	return _EphemeralContainerArrayType
}

func (a EphemeralContainerArray) ToEphemeralContainerArrayOutput() EphemeralContainerArrayOutput {
	return pulumi.ToOutput(a).(EphemeralContainerArrayOutput)
}

func (a EphemeralContainerArray) ToEphemeralContainerArrayOutputWithContext(ctx context.Context) EphemeralContainerArrayOutput {
	return pulumi.ToOutputWithContext(ctx, a).(EphemeralContainerArrayOutput)
}

type EphemeralContainerArrayOutput struct { *pulumi.OutputState }

func init() { pulumi.RegisterOutputType(EphemeralContainerArrayOutput{}) }

func (EphemeralContainerArrayOutput) ElementType() reflect.Type {
	return _EphemeralContainerArrayType
}

func (o EphemeralContainerArrayOutput) Index(i pulumi.IntInput) EphemeralContainerOutput {
	return pulumi.All(o, i).Apply(func(vs []interface{}) EphemeralContainer {
		return vs[0].([]EphemeralContainer)[vs[1].(int)]
	}).(EphemeralContainerOutput)
}
