// *** WARNING: this file was generated by the Pulumi Kubernetes codegen tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v1

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/go/pulumi"
	metaV1 "github.com/pulumi/pulumi-kubernetes/sdk/go/kubernetes/meta/v1"
)

// TopologySpreadConstraint specifies how to spread matching pods among the given topology.
type TopologySpreadConstraint struct {
	// LabelSelector is used to find matching pods. Pods that match this label selector are counted to
	// determine the number of pods in their corresponding topology domain.
	LabelSelector *metaV1.LabelSelector `pulumi:"labelSelector"`

	// MaxSkew describes the degree to which pods may be unevenly distributed. It's the maximum
	// permitted difference between the number of matching pods in any two topology domains of a given
	// topology type. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
	// labelSelector spread as 1/1/0: | zone1 | zone2 | zone3 | |   P   |   P   |       | - if MaxSkew
	// is 1, incoming pod can only be scheduled to zone3 to become 1/1/1; scheduling it onto
	// zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2) violate MaxSkew(1). - if MaxSkew is
	// 2, incoming pod can be scheduled onto any zone. It's a required field. Default value is 1 and 0
	// is not allowed.
	MaxSkew int `pulumi:"maxSkew"`

	// TopologyKey is the key of node labels. Nodes that have a label with this key and identical
	// values are considered to be in the same topology. We consider each <key, value> as a "bucket",
	// and try to put balanced number of pods into each bucket. It's a required field.
	TopologyKey string `pulumi:"topologyKey"`

	// WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy the spread constraint.
	// - DoNotSchedule (default) tells the scheduler not to schedule it - ScheduleAnyway tells the
	// scheduler to still schedule it It's considered as "Unsatisfiable" if and only if placing
	// incoming pod on any topology violates "MaxSkew". For example, in a 3-zone cluster, MaxSkew is
	// set to 1, and pods with the same labelSelector spread as 3/1/1: | zone1 | zone2 | zone3 | | P P
	// P |   P   |   P   | If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be
	// scheduled to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
	// MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler won't make it
	// *more* imbalanced. It's a required field.
	WhenUnsatisfiable string `pulumi:"whenUnsatisfiable"`

}

var _TopologySpreadConstraintType = reflect.TypeOf((*TopologySpreadConstraint)(nil)).Elem()

// TopologySpreadConstraintInput represents an input type that resolves to a TopologySpreadConstraint.
type TopologySpreadConstraintInput interface {
	ElementType() reflect.Type

	ToTopologySpreadConstraintOutput() TopologySpreadConstraintOutput
	ToTopologySpreadConstraintOutputWithContext(ctx context.Context) TopologySpreadConstraintOutput
}

// TopologySpreadConstraintArgs is a TopologySpreadConstraintInput whose fields are all Input types.
type TopologySpreadConstraintArgs struct {
	// MaxSkew describes the degree to which pods may be unevenly distributed. It's the maximum
	// permitted difference between the number of matching pods in any two topology domains of a given
	// topology type. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
	// labelSelector spread as 1/1/0: | zone1 | zone2 | zone3 | |   P   |   P   |       | - if MaxSkew
	// is 1, incoming pod can only be scheduled to zone3 to become 1/1/1; scheduling it onto
	// zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2) violate MaxSkew(1). - if MaxSkew is
	// 2, incoming pod can be scheduled onto any zone. It's a required field. Default value is 1 and 0
	// is not allowed.
	MaxSkew pulumi.IntInput `pulumi:"maxSkew"`

	// TopologyKey is the key of node labels. Nodes that have a label with this key and identical
	// values are considered to be in the same topology. We consider each <key, value> as a "bucket",
	// and try to put balanced number of pods into each bucket. It's a required field.
	TopologyKey pulumi.StringInput `pulumi:"topologyKey"`

	// WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy the spread constraint.
	// - DoNotSchedule (default) tells the scheduler not to schedule it - ScheduleAnyway tells the
	// scheduler to still schedule it It's considered as "Unsatisfiable" if and only if placing
	// incoming pod on any topology violates "MaxSkew". For example, in a 3-zone cluster, MaxSkew is
	// set to 1, and pods with the same labelSelector spread as 3/1/1: | zone1 | zone2 | zone3 | | P P
	// P |   P   |   P   | If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be
	// scheduled to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
	// MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler won't make it
	// *more* imbalanced. It's a required field.
	WhenUnsatisfiable pulumi.StringInput `pulumi:"whenUnsatisfiable"`

	// LabelSelector is used to find matching pods. Pods that match this label selector are counted to
	// determine the number of pods in their corresponding topology domain.
	LabelSelector metaV1.LabelSelectorInput `pulumi:"labelSelector"`

}

func (a TopologySpreadConstraintArgs) ElementType() reflect.Type {
	return _TopologySpreadConstraintType
}

func (a TopologySpreadConstraintArgs) ToTopologySpreadConstraintOutput() TopologySpreadConstraintOutput {
	return pulumi.ToOutput(a).(TopologySpreadConstraintOutput)
}

func (a TopologySpreadConstraintArgs) ToTopologySpreadConstraintOutputWithContext(ctx context.Context) TopologySpreadConstraintOutput {
	return pulumi.ToOutputWithContext(ctx, a).(TopologySpreadConstraintOutput)
}

// TopologySpreadConstraintOutput is an output type that resolves to a Input.
type TopologySpreadConstraintOutput struct { *pulumi.OutputState }

func init() { pulumi.RegisterOutputType(TopologySpreadConstraintOutput{}) }

func (TopologySpreadConstraintOutput) ElementType() reflect.Type {
	return _TopologySpreadConstraintType
}

func (o TopologySpreadConstraintOutput) LabelSelector() metaV1.LabelSelectorOutput {
	return o.Apply(func(v TopologySpreadConstraint) *metaV1.LabelSelector {
		return v.LabelSelector
	}).(metaV1.LabelSelectorOutput)
}

func (o TopologySpreadConstraintOutput) MaxSkew() pulumi.IntOutput {
	return o.Apply(func(v TopologySpreadConstraint) int {
		return v.MaxSkew
	}).(pulumi.IntOutput)
}

func (o TopologySpreadConstraintOutput) TopologyKey() pulumi.StringOutput {
	return o.Apply(func(v TopologySpreadConstraint) string {
		return v.TopologyKey
	}).(pulumi.StringOutput)
}

func (o TopologySpreadConstraintOutput) WhenUnsatisfiable() pulumi.StringOutput {
	return o.Apply(func(v TopologySpreadConstraint) string {
		return v.WhenUnsatisfiable
	}).(pulumi.StringOutput)
}

var _TopologySpreadConstraintArrayType = reflect.TypeOf((*[]TopologySpreadConstraint)(nil)).Elem()

type TopologySpreadConstraintArrayInput interface {
	ElementType() reflect.Type

	ToTopologySpreadConstraintArrayOutput() TopologySpreadConstraintArrayOutput
	ToTopologySpreadConstraintArrayOutputWithContext(ctx context.Context) TopologySpreadConstraintArrayOutput
}

type TopologySpreadConstraintArray []TopologySpreadConstraintInput

func (a TopologySpreadConstraintArray) ElementType() reflect.Type {
	return _TopologySpreadConstraintArrayType
}

func (a TopologySpreadConstraintArray) ToTopologySpreadConstraintArrayOutput() TopologySpreadConstraintArrayOutput {
	return pulumi.ToOutput(a).(TopologySpreadConstraintArrayOutput)
}

func (a TopologySpreadConstraintArray) ToTopologySpreadConstraintArrayOutputWithContext(ctx context.Context) TopologySpreadConstraintArrayOutput {
	return pulumi.ToOutputWithContext(ctx, a).(TopologySpreadConstraintArrayOutput)
}

type TopologySpreadConstraintArrayOutput struct { *pulumi.OutputState }

func init() { pulumi.RegisterOutputType(TopologySpreadConstraintArrayOutput{}) }

func (TopologySpreadConstraintArrayOutput) ElementType() reflect.Type {
	return _TopologySpreadConstraintArrayType
}

func (o TopologySpreadConstraintArrayOutput) Index(i pulumi.IntInput) TopologySpreadConstraintOutput {
	return pulumi.All(o, i).Apply(func(vs []interface{}) TopologySpreadConstraint {
		return vs[0].([]TopologySpreadConstraint)[vs[1].(int)]
	}).(TopologySpreadConstraintOutput)
}
