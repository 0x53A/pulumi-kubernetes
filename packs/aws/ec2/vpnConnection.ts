// *** WARNING: this file was generated by the Lumi Terraform Bridge (TFGEN) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as lumi from "@lumi/lumi";

export class VpnConnection extends lumi.NamedResource implements VpnConnectionArgs {
    public readonly customerGatewayConfiguration?: string;
    public readonly customerGatewayId: string;
    public readonly routes?: { destinationCidrBlock?: string, source?: string, state?: string }[];
    public readonly staticRoutesOnly?: boolean;
    public readonly tags?: {[key: string]: any};
    public readonly tunnel1Address?: string;
    public readonly tunnel1BgpAsn?: string;
    public readonly tunnel1BgpHoldtime?: number;
    public readonly tunnel1CgwInsideAddress?: string;
    public readonly tunnel1PresharedKey?: string;
    public readonly tunnel1VgwInsideAddress?: string;
    public readonly tunnel2Address?: string;
    public readonly tunnel2BgpAsn?: string;
    public readonly tunnel2BgpHoldtime?: number;
    public readonly tunnel2CgwInsideAddress?: string;
    public readonly tunnel2PresharedKey?: string;
    public readonly tunnel2VgwInsideAddress?: string;
    public readonly type: string;
    public readonly vgwTelemetry?: { acceptedRouteCount?: number, lastStatusChange?: string, outsideIpAddress?: string, status?: string, statusMessage?: string }[];
    public readonly vpnGatewayId: string;

    constructor(name: string, args: VpnConnectionArgs) {
        super(name);
        this.customerGatewayConfiguration = args.customerGatewayConfiguration;
        if (args.customerGatewayId === undefined) {
            throw new Error("Property argument 'customerGatewayId' is required, but was missing");
        }
        this.customerGatewayId = args.customerGatewayId;
        this.routes = args.routes;
        this.staticRoutesOnly = args.staticRoutesOnly;
        this.tags = args.tags;
        if (args.tunnel1Address === undefined) {
            throw new Error("Property argument 'tunnel1Address' is required, but was missing");
        }
        this.tunnel1Address = args.tunnel1Address;
        if (args.tunnel1BgpAsn === undefined) {
            throw new Error("Property argument 'tunnel1BgpAsn' is required, but was missing");
        }
        this.tunnel1BgpAsn = args.tunnel1BgpAsn;
        if (args.tunnel1BgpHoldtime === undefined) {
            throw new Error("Property argument 'tunnel1BgpHoldtime' is required, but was missing");
        }
        this.tunnel1BgpHoldtime = args.tunnel1BgpHoldtime;
        if (args.tunnel1CgwInsideAddress === undefined) {
            throw new Error("Property argument 'tunnel1CgwInsideAddress' is required, but was missing");
        }
        this.tunnel1CgwInsideAddress = args.tunnel1CgwInsideAddress;
        if (args.tunnel1PresharedKey === undefined) {
            throw new Error("Property argument 'tunnel1PresharedKey' is required, but was missing");
        }
        this.tunnel1PresharedKey = args.tunnel1PresharedKey;
        if (args.tunnel1VgwInsideAddress === undefined) {
            throw new Error("Property argument 'tunnel1VgwInsideAddress' is required, but was missing");
        }
        this.tunnel1VgwInsideAddress = args.tunnel1VgwInsideAddress;
        if (args.tunnel2Address === undefined) {
            throw new Error("Property argument 'tunnel2Address' is required, but was missing");
        }
        this.tunnel2Address = args.tunnel2Address;
        if (args.tunnel2BgpAsn === undefined) {
            throw new Error("Property argument 'tunnel2BgpAsn' is required, but was missing");
        }
        this.tunnel2BgpAsn = args.tunnel2BgpAsn;
        if (args.tunnel2BgpHoldtime === undefined) {
            throw new Error("Property argument 'tunnel2BgpHoldtime' is required, but was missing");
        }
        this.tunnel2BgpHoldtime = args.tunnel2BgpHoldtime;
        if (args.tunnel2CgwInsideAddress === undefined) {
            throw new Error("Property argument 'tunnel2CgwInsideAddress' is required, but was missing");
        }
        this.tunnel2CgwInsideAddress = args.tunnel2CgwInsideAddress;
        if (args.tunnel2PresharedKey === undefined) {
            throw new Error("Property argument 'tunnel2PresharedKey' is required, but was missing");
        }
        this.tunnel2PresharedKey = args.tunnel2PresharedKey;
        if (args.tunnel2VgwInsideAddress === undefined) {
            throw new Error("Property argument 'tunnel2VgwInsideAddress' is required, but was missing");
        }
        this.tunnel2VgwInsideAddress = args.tunnel2VgwInsideAddress;
        if (args.type === undefined) {
            throw new Error("Property argument 'type' is required, but was missing");
        }
        this.type = args.type;
        this.vgwTelemetry = args.vgwTelemetry;
        if (args.vpnGatewayId === undefined) {
            throw new Error("Property argument 'vpnGatewayId' is required, but was missing");
        }
        this.vpnGatewayId = args.vpnGatewayId;
    }
}

export interface VpnConnectionArgs {
    readonly customerGatewayConfiguration?: string;
    readonly customerGatewayId: string;
    readonly routes?: { destinationCidrBlock?: string, source?: string, state?: string }[];
    readonly staticRoutesOnly?: boolean;
    readonly tags?: {[key: string]: any};
    readonly tunnel1Address?: string;
    readonly tunnel1BgpAsn?: string;
    readonly tunnel1BgpHoldtime?: number;
    readonly tunnel1CgwInsideAddress?: string;
    readonly tunnel1PresharedKey?: string;
    readonly tunnel1VgwInsideAddress?: string;
    readonly tunnel2Address?: string;
    readonly tunnel2BgpAsn?: string;
    readonly tunnel2BgpHoldtime?: number;
    readonly tunnel2CgwInsideAddress?: string;
    readonly tunnel2PresharedKey?: string;
    readonly tunnel2VgwInsideAddress?: string;
    readonly type: string;
    readonly vgwTelemetry?: { acceptedRouteCount?: number, lastStatusChange?: string, outsideIpAddress?: string, status?: string, statusMessage?: string }[];
    readonly vpnGatewayId: string;
}

